// Each #kernel tells which function to compile; you can have many kernels

// Kernel's
// ====================================================================================
#if 1

#pragma kernel SampleSDF
#pragma kernel CheckSignFlips
#pragma kernel ExtractHermiteData
#pragma kernel SolveQEF
#pragma kernel Triangulate

#endif
// ====================================================================================

// General
// ====================================================================================
#if 1 
struct Hermite
{
    float3 position;
    float3 normal;
    float d0;
    float d1;
};

struct Sphere
{
    float3 position;
    uint isSolid;
    uint exists;
};

RWStructuredBuffer<float> sdfValues;
RWStructuredBuffer<uint> activeCells;
RWStructuredBuffer<Hermite> hermiteData;
RWStructuredBuffer<uint> hermiteCounts;
RWStructuredBuffer<float3> cellVertices;
RWStructuredBuffer<uint3> triangles;

StructuredBuffer<Sphere> Spheres;

cbuffer Params
{
    int gridResolution;
    int cornerResolution;
    int gridCorners;
    int gridEdges;
    float sRadius;
    float smoothing;
    int _NumSpheres;
    
    float3 boundStart;
    float3 boundEnd;
};

uint GetPointIDOnGrid(int x, int y, int z)
{
    return (uint) (x + y * gridResolution + z * gridResolution * gridResolution);
}

float3 GetPointFromGridID(uint gridID)
{
    float3 p;
    
    p.x = gridID % gridResolution;
    p.y = (gridID / gridResolution) % gridResolution;
    p.z = gridID / (gridResolution * gridResolution);
    
    return p;
}

uint GetPointIDOnGridCorner(int x, int y, int z)
{
    return (uint) (x + y * cornerResolution + z * cornerResolution * cornerResolution);
}

float3 GetPointFromGridCornerID(uint gridID)
{
    float3 p;
    
    p.x = gridID % cornerResolution;
    p.y = (gridID / cornerResolution) % cornerResolution;
    p.z = gridID / (cornerResolution * cornerResolution);
    
    return p;
}

float3 CornerWorldPos(int x, int y, int z)
{
    float3 t = float3(x, y, z) / float(cornerResolution - 1);
    return lerp(boundStart, boundEnd, t);
}

#endif

// Sample SDF's
// ====================================================================================
#if 1

// Calculates the SDF of a sphere
float SDFSphere(float3 pos, float3 centre, float radius)
{
    return length(centre - pos) - radius;
}

float smin(float a, float b, float k)
{
    k *= 1.0;
    float r = exp2(-a / k) + exp2(-b / k);
    return -k * log2(r);
}

float SDFScene(float3 pos)
{
    float maxDistance = 1000.0;
    float distance;
    distance = maxDistance;
    
    for (int i = 0; i < _NumSpheres; i++)
    {
        Sphere sphere = Spheres[i];
        float distanceToSphere = SDFSphere(pos, sphere.position, sRadius);

        distance = smin(distance, distanceToSphere, smoothing);

    }
    return distance;
}

[numthreads(8,8,8)]
void SampleSDF(uint3 id : SV_DispatchThreadID)
{   
    if (id.x >= (uint) cornerResolution ||
        id.y >= (uint) cornerResolution ||
        id.z >= (uint) cornerResolution)
        return;
    
    int3 gc = int3(id);

    float3 t = float3(gc) / (cornerResolution - 1);
    float3 worldPos = lerp(boundStart, boundEnd, t);
    
    float d = SDFScene(worldPos);
    
    uint index = GetPointIDOnGridCorner(gc.x, gc.y, gc.z);
    sdfValues[index] = d;
}
#endif

// CheckSignFlips
// ====================================================================================
#if 1
static const int3 CUBE_CORNERS[8] =
{
    int3(0, 0, 0),
    int3(1, 0, 0),
    int3(1, 1, 0),
    int3(0, 1, 0),
    int3(0, 0, 1),
    int3(1, 0, 1),
    int3(1, 1, 1),
    int3(0, 1, 1)
};

static const uint2 EDGE_INDEX[12] =
{
    uint2(0, 1), uint2(1, 2), uint2(2, 3), uint2(3, 0), // bottom edges
    uint2(4, 5), uint2(5, 6), uint2(6, 7), uint2(7, 4), // top edges
    uint2(0, 4), uint2(1, 5), uint2(2, 6), uint2(3, 7) // vertical edges
};


[numthreads(8, 8, 8)]
void CheckSignFlips(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) gridResolution ||
        id.y >= (uint) gridResolution ||
        id.z >= (uint) gridResolution)
        return;

    int3 cell = int3(id);

    uint cellIndex = GetPointIDOnGrid(cell.x, cell.y, cell.z);

    // Unroll tells the compiler to write the body inline for the amount it is supposed to run instead of creating an actual loop
    float cornerSDF[8];
    [unroll]
    for (int i = 0; i < 8; i++)
    {
        int3 c = cell + CUBE_CORNERS[i];
        uint index = GetPointIDOnGridCorner(c.x, c.y, c.z);
        cornerSDF[i] = sdfValues[index];
    }

    bool hasFlip = false;
    [unroll]
    for (int e = 0; e < 12; e++)
    {
        float a = cornerSDF[EDGE_INDEX[e].x];
        float b = cornerSDF[EDGE_INDEX[e].y];

        if ((a < 0 && b >= 0) || (a >= 0 && b < 0))
        {
            hasFlip = true;
        }
    }

    // Mark cell as active
    activeCells[cellIndex] = hasFlip ? (uint)1 : (uint)0;
}

#endif
// ExtractHermiteData
// ====================================================================================
#if 1

float3 ComputeNormal(float3 pos)
{
    float epsilon = 0.001f;
    return normalize(float3(SDFScene(pos + float3(epsilon, 0, 0)) - SDFScene(pos - float3(epsilon, 0, 0)),
                            SDFScene(pos + float3(0, epsilon, 0)) - SDFScene(pos - float3(0, epsilon, 0)),
                            SDFScene(pos + float3(0, 0, epsilon)) - SDFScene(pos - float3(0, 0, epsilon))));
}


[numthreads(8, 8, 8)]
void ExtractHermiteData(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) gridResolution ||
        id.y >= (uint) gridResolution ||
        id.z >= (uint) gridResolution)
        return;

    int3 cell = int3(id);
    uint cellIndex = GetPointIDOnGrid(cell.x, cell.y, cell.z);

    if (activeCells[cellIndex] == 0)
    {
        hermiteCounts[cellIndex] = 0;
        return;
    }

    float cornerSDF[8];
    float3 cornerPos[8];

    [unroll]
    for (int i = 0; i < 8; i++)
    {
        int3 c = cell + CUBE_CORNERS[i];

        uint cornerIndex = GetPointIDOnGridCorner(c.x, c.y, c.z);
        cornerSDF[i] = sdfValues[cornerIndex];

        float3 t = float3(c) / (cornerResolution - 1);
        cornerPos[i] = lerp(boundStart, boundEnd, t);
    }

    uint count = 0;

    [unroll]
    for (int e = 0; e < 12; e++)
    {
        int c0 = EDGE_INDEX[e].x;
        int c1 = EDGE_INDEX[e].y;

        float d0 = cornerSDF[c0];
        float d1 = cornerSDF[c1];
        uint index = cellIndex * 12 + e;
        
        hermiteData[index].position = float3(0, 0, 0);
        hermiteData[index].normal = float3(0, 0, 0);
        hermiteData[index].d0 = 0;
        hermiteData[index].d1 = 0;
        
        if ((d0 < 0 && d1 >= 0) || (d0 >= 0 && d1 < 0))
        {
            // Compute intersection t parameter
            float t = d0 / (d0 - d1);

            float3 p = lerp(cornerPos[c0], cornerPos[c1], t);

            float3 n = ComputeNormal(p);

            uint writeIndex = cellIndex * 12 + count;
            hermiteData[writeIndex].position = p;
            hermiteData[writeIndex].normal = n;
            hermiteData[writeIndex].d0 = d0;
            hermiteData[writeIndex].d1= d1;

            count++;
        }
    }

    hermiteCounts[cellIndex] = count;
}

#endif
// SolveQEF
// ====================================================================================
#if 1

[numthreads(8, 8, 8)]
void SolveQEF(uint3 id : SV_DispatchThreadID)
{
    int cellRes = cornerResolution - 1;
    if (id.x >= cellRes || id.y >= cellRes || id.z >= cellRes)
        return;

    uint cellID = GetPointIDOnGrid(id.x, id.y, id.z);

    uint count = hermiteCounts[cellID];
    if (count < 3)
    {
        cellVertices[cellID] = float3(0, 0, 0);
        return;
    }

    // centroid
    float3 _centroid = 0;
    for (uint i = 0; i < count; i++)
    {
        _centroid += hermiteData[cellID * 12 + i].position;
    }
    _centroid /= count;

    // build A and b
    float3x3 A = 0;
    float3 b = 0;

    for (uint i = 0; i < count; i++)
    {
        Hermite h = hermiteData[cellID * 12 + i];
        float3 normal = h.normal;
        float d = dot(normal, h.position - _centroid);

        A += float3x3(
            normal.x * normal.x, normal.x * normal.y, normal.x * normal.z,
            normal.y * normal.x, normal.y * normal.y, normal.y * normal.z,
            normal.z * normal.x, normal.z * normal.y, normal.z * normal.z
        );

        b += normal * d;
    }

    // solve A d = b 
    float det =
          A[0][0] * (A[1][1] * A[2][2] - A[1][2] * A[2][1])
        - A[0][1] * (A[1][0] * A[2][2] - A[1][2] * A[2][0])
        + A[0][2] * (A[1][0] * A[2][1] - A[1][1] * A[2][0]);

    float3 result = _centroid;

    if (abs(det) > 1e-6)
    {
        float invDet = 1.0 / det;

        float3x3 invA;
        invA[0] = invDet * float3(
            A[1][1] * A[2][2] - A[1][2] * A[2][1],
            A[0][2] * A[2][1] - A[0][1] * A[2][2],
            A[0][1] * A[1][2] - A[0][2] * A[1][1]
        );
        invA[1] = invDet * float3(
            A[1][2] * A[2][0] - A[1][0] * A[2][2],
            A[0][0] * A[2][2] - A[0][2] * A[2][0],
            A[0][2] * A[1][0] - A[0][0] * A[1][2]
        );
        invA[2] = invDet * float3(
            A[1][0] * A[2][1] - A[1][1] * A[2][0],
            A[0][1] * A[2][0] - A[0][0] * A[2][1],
            A[0][0] * A[1][1] - A[0][1] * A[1][0]
        );

        float3 d = mul(invA, b);
        result = _centroid + d;
    }

    // clamp inside cell
    float3 cellMin = CornerWorldPos(id.x, id.y, id.z);
    float3 cellMax = CornerWorldPos(id.x + 1, id.y + 1, id.z + 1);
    result = clamp(result, cellMin, cellMax);

    cellVertices[cellID] = result;
}

#endif
// Triangulate
// ====================================================================================
#if 1

[numthreads(8, 8, 8)]
void Triangulate(uint3 id : SV_DispatchThreadID)
{
    int cellRes = cornerResolution - 1;
    if (id.x >= cellRes || id.y >= cellRes || id.z >= cellRes)
        return;

    uint cellID = GetPointIDOnGrid(id.x, id.y, id.z);

    if (hermiteCounts[cellID] == 0)
        return;

    uint base = cellID * 6;
    uint t = 0;

    // ---------- +X ----------
    if (id.x + 1 < cellRes)
    {
        uint nx = GetPointIDOnGrid(id.x + 1, id.y, id.z);
        if (hermiteCounts[nx] > 0)
        {
            triangles[base + t++] = uint3(
                cellID,
                GetPointIDOnGrid(id.x, id.y + 1, id.z),
                GetPointIDOnGrid(id.x, id.y + 1, id.z + 1)
            );
            triangles[base + t++] = uint3(
                cellID,
                GetPointIDOnGrid(id.x, id.y + 1, id.z + 1),
                GetPointIDOnGrid(id.x, id.y, id.z + 1)
            );
        }
    }

    // ---------- +Y ----------
    if (id.y + 1 < cellRes)
    {
        uint ny = GetPointIDOnGrid(id.x, id.y + 1, id.z);
        if (hermiteCounts[ny] > 0)
        {
            triangles[base + t++] = uint3(
                cellID,
                GetPointIDOnGrid(id.x + 1, id.y, id.z),
                GetPointIDOnGrid(id.x + 1, id.y, id.z + 1)
            );
            triangles[base + t++] = uint3(
                cellID,
                GetPointIDOnGrid(id.x + 1, id.y, id.z + 1),
                GetPointIDOnGrid(id.x, id.y, id.z + 1)
            );
        }
    }

    // ---------- +Z ----------
    if (id.z + 1 < cellRes)
    {
        uint nz = GetPointIDOnGrid(id.x, id.y, id.z + 1);
        if (hermiteCounts[nz] > 0)
        {
            triangles[base + t++] = uint3(
                cellID,
                GetPointIDOnGrid(id.x + 1, id.y, id.z),
                GetPointIDOnGrid(id.x + 1, id.y + 1, id.z)
            );
            triangles[base + t++] = uint3(
                cellID,
                GetPointIDOnGrid(id.x + 1, id.y + 1, id.z),
                GetPointIDOnGrid(id.x, id.y + 1, id.z)
            );
        }
    }

    // fill unused slots with degenerate triangles
    for (; t < 6; t++)
        triangles[base + t] = uint3(0, 0, 0);
}

#endif
